name: 'decaf'
description: 'Deploy your project with ease'

inputs:
  github_token:
    description: 'GITHUB_TOKEN or a repo scoped PAT.'
    default: ${{ github.token }}
  git_config:
    description: 'The committer name and email address in the format Display Name <email@address.com>. Defaults to the GitHub Actions bot user on github.com. Tool will set this as the committer for any git operations that you make in your deploy script. Else, provide an empty string for tool to not configure git.'
    default: 'github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>'
  deploy:
    description: 'Command to run to deploy your project.'
    required: true
    default: ''
  get_latest_release_current_branch:
    description: 'Command to run to get the latest release version for the current branch.'
    default: ''
  get_next_release_version:
    description: 'Command to run to get the next release version.'
    default: ''
  simulated_merge_type:
    description: 'When running in a pull request, what type of merge to simulate to run the tool in test mode. Options: merge, squash, rebase. Can be a single value or comma-separated list (e.g., "merge,squash,rebase").'
    default: '' # options: merge, squash, rebase (or comma-separated combination)
  make_pull_request_comment:
    description: 'If a pull request comment should be made. Value is string values "true" or "false".'
    default: 'true'
  compile_binary:
    description: 'If you want to compile & run the tool instead of downloading the latest release from GitHub. This is used to test pre-release versions of the tool. Value is string values "true" or "false".'
    default: 'false'
  fail_on_deploy_verification:
    description: 'After deployment commands run, the tool will re-run get latest release command and compare returned version to version just deployed. This option determines if the tool should fail if the versions do not match compared to simply showing a warning. Value is string values "true" or "false". Default is "true". Always "false" in test mode.'
    default: 'true'
  branch_filters:
    description: 'Comma-separated list of regex patterns to filter which branches to analyze for commits. Empty string means analyze all branches (default behavior). Example: "main,develop,feature/*,release/*". Branches not matching any pattern will have empty commit arrays in the input data.'
    default: ''
  commit_limit:
    description: 'Maximum number of commits to retrieve and parse for each branch. This helps improve performance for repositories with many commits. Default is 500.'
    default: ''

outputs:
  new_release_version:
    description: 'If a new release was created, this is the version of that release.'
    value: ${{ steps.deployment.outputs.new_release_version }}
  test_mode_on:
    description: 'If test mode was on when the tool ran. Value is string values "true" or "false".'
    value: ${{ steps.deployment.outputs.test_mode_on }}

runs:
  using: "composite"
  steps:  
    # If someone runs this action, we need to install the compiled binary. 
    - name: Download deployment tool binary
      if: ${{ inputs.compile_binary == 'false' }}
      # chmod so we can execute the install script. 
      # run install script, but with the version that is hard-coded to this github action that gets downloaded. 
      # GITHUB_ACTION_PATH gives you the directory to this action on the CI. 
      run: |
        chmod +x ${GITHUB_ACTION_PATH}/install
        ${GITHUB_ACTION_PATH}/install $(cat ${GITHUB_ACTION_PATH}/version.txt)
      shell: bash

    - name: Set up Deno
      if: ${{ inputs.compile_binary == 'true' }}
      uses: denoland/setup-deno@v1
      with:
        # pinning version until bug fixed: https://github.com/denoland/deno/issues/31556
        deno-version: v2.5.6

    - name: Compile binary
      if: ${{ inputs.compile_binary == 'true' }}
      working-directory: ${{ github.action_path }}
      run: OUTPUT_FILE_NAME=decaf DENO_TARGET="$(uname -m)-unknown-linux-gnu" deno task compile
      shell: bash

    # when this action is being executed by *this decaf project*, we dont want to run this cp command because 
    # the decaf binary will already exist in our workspace directory. But if I want to run a pre-production version of this tool 
    # from a different project, not this one, I need to cp the compiled binary created above into the relative path so we can call it. 
    - name: Copy compiled binary to workspace
      if: ${{ inputs.compile_binary == 'true' }}
      shell: bash
      run: |
        if [ ! -f "${{ github.workspace }}/decaf" ]; then
          cp ${{ github.action_path }}/decaf ${{ github.workspace }}/decaf
        fi

    - name: Run deployment tool 
      # Deno's runtime permissions are a great feature. It would be nice to take advantage of it, however, it may not be possible with future features like running plugins. 
      #
      # The directories we are giving permission to read and write to are the temp directories for all of the OSes that GitHub Actions supports. /tmp for linux and /var/folders for macOS.
      run: |
        ./decaf \
          --github_token "${{ inputs.github_token }}" \
          --git_config "${{ inputs.git_config }}" \
          --deploy "${{ inputs.deploy }}" \
          --get_latest_release_current_branch "${{ inputs.get_latest_release_current_branch }}" \
          --get_next_release_version "${{ inputs.get_next_release_version }}" \
          --simulated_merge_type "${{ inputs.simulated_merge_type }}" \
          --branch_filters "${{ inputs.branch_filters }}" \
          --commit_limit "${{ inputs.commit_limit }}"
      shell: bash


