name: 'decaf'
description: 'Deploy your project with ease'

inputs:
  github_token:
    description: 'GITHUB_TOKEN or a repo scoped PAT.'
    default: ${{ github.token }}
  git_config:
    description: 'The committer name and email address in the format Display Name <email@address.com>. Defaults to the GitHub Actions bot user on github.com. Tool will set this as the committer for any git operations that you make in your deploy script. Else, provide an empty string for tool to not configure git.'
    default: 'github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>'
  deploy:
    description: 'Command to run to deploy your project.'
    required: true
    default: ''
  get_latest_release_current_branch:
    description: 'Command to run to get the latest release version for the current branch.'
    default: ''
  get_next_release_version:
    description: 'Command to run to get the next release version.'
    default: ''
  simulated_merge_type:
    description: 'When running in a pull request, what type of merge to simulate to run the tool in test mode. Options: merge, squash, rebase. Can be a single value or comma-separated list (e.g., "merge,squash,rebase").'
    default: '' # options: merge, squash, rebase (or comma-separated combination)
  make_pull_request_comment:
    description: 'If a pull request comment should be made. Value is string values "true" or "false".'
    default: 'true'
  compile_binary:
    description: 'If you want to compile & run the tool instead of downloading the latest release from GitHub. This is used to test pre-release versions of the tool. Value is string values "true" or "false".'
    default: 'false'
  fail_on_deploy_verification:
    description: 'After deployment commands run, the tool will re-run get latest release command and compare returned version to version just deployed. This option determines if the tool should fail if the versions do not match compared to simply showing a warning. Value is string values "true" or "false". Default is "true". Always "false" in test mode.'
    default: 'true'
  branch_filters:
    description: 'Comma-separated list of regex patterns to filter which branches to analyze for commits. Empty string means analyze all branches (default behavior). Example: "main,develop,feature/*,release/*". Branches not matching any pattern will have empty commit arrays in the input data.'
    default: ''
  commit_limit:
    description: 'Maximum number of commits to retrieve and parse for each branch. This helps improve performance for repositories with many commits. Default is 500.'
    default: ''
  pull_request_comment_template_file:
    description: 'Path to a file (relative to the repository root) containing the template for the pull request comment. If both this and pull_request_comment_template are provided, this takes precedence.'
    default: ''
  pull_request_comment_template:
    description: 'Template string for the pull request comment. Used if pull_request_comment_template_file is not provided.'
    default: ''

outputs:
  new_release_version:
    description: 'If a new release was created, this is the version of that release.'
    value: ${{ steps.deployment.outputs.new_release_version }}
  test_mode_on:
    description: 'If test mode was on when the tool ran. Value is string values "true" or "false".'
    value: ${{ steps.deployment.outputs.test_mode_on }}

runs:
  using: "composite"
  steps:  
    # If someone runs this action, we need to install the compiled binary. 
    - name: Download deployment tool binary
      if: ${{ inputs.compile_binary == 'false' }}
      # chmod so we can execute the install script. 
      # run install script, but with the version that is hard-coded to this github action that gets downloaded. 
      # GITHUB_ACTION_PATH gives you the directory to this action on the CI. 
      run: |
        chmod +x ${GITHUB_ACTION_PATH}/install
        ${GITHUB_ACTION_PATH}/install $(cat ${GITHUB_ACTION_PATH}/version.txt)
      shell: bash

    - name: Set up Deno
      if: ${{ inputs.compile_binary == 'true' }}
      uses: asdf-vm/actions/install@v4

    # compile binary and put into a location in PATH. the path matches what's in the ./install script.
    - name: Compile binary
      if: ${{ inputs.compile_binary == 'true' }}
      working-directory: ${{ github.action_path }}
      run: |
        OUTPUT_FILE_NAME=decaf DENO_TARGET="$(uname -m)-unknown-linux-gnu" deno task compile
        mkdir -p "${HOME}/.local/bin"
        mv ./decaf "${HOME}/.local/bin"
      shell: bash

    # if you provide a template string in the actions workflow file, it probably has quotes in it that need to be escaped in order to pass 
    # it as a CLI command argument. The easiest way to do that is to write it to a temp file and pass the file path instead.
    - name: Prepare pull request comment template
      if: ${{ inputs.pull_request_comment_template != '' && inputs.pull_request_comment_template_file == '' }}
      shell: bash
      run: |
        cat > /tmp/decaf-pr-template.txt << 'DECAF_TEMPLATE_EOF'
        ${{ inputs.pull_request_comment_template }}
        DECAF_TEMPLATE_EOF
        echo "DECAF_TEMPLATE_FILE=/tmp/decaf-pr-template.txt" >> $GITHUB_ENV

    - name: Run deployment tool 
      # Deno's runtime permissions are a great feature. It would be nice to take advantage of it, however, it may not be possible with future features like running plugins. 
      #
      # The directories we are giving permission to read and write to are the temp directories for all of the OSes that GitHub Actions supports. /tmp for linux and /var/folders for macOS.
      run: |
        PULL_REQUEST_COMMENT_TEMPLATE=${{ inputs.pull_request_comment_template }}
        decaf \
          --github_token "${{ inputs.github_token }}" \
          --git_config "${{ inputs.git_config }}" \
          --deploy "${{ inputs.deploy }}" \
          --get_latest_release_current_branch "${{ inputs.get_latest_release_current_branch }}" \
          --get_next_release_version "${{ inputs.get_next_release_version }}" \
          --simulated_merge_type "${{ inputs.simulated_merge_type }}" \
          --branch_filters "${{ inputs.branch_filters }}" \
          --commit_limit "${{ inputs.commit_limit }}" \
          --pull_request_comment_template_file "${{ inputs.pull_request_comment_template_file || env.DECAF_TEMPLATE_FILE }}"
      shell: bash


